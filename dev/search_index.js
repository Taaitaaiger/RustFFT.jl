var documenterSearchIndex = {"docs":
[{"location":"#RustFFT-Documentation","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"","category":"section"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"Compute FFTs in Julia using RustFFT. Some parts of this documentation have been quoted from the RustFFT docs.","category":"page"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"RustFFT is a high-performance, SIMD-accelerated FFT library written in pure Rust. It can compute FFTs of any size, including prime-number sizes, in O(nlogn) time.","category":"page"},{"location":"#Usage","page":"RustFFT Documentation","title":"Usage","text":"","category":"section"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"RustFFT.jl implements the generic FFT interface of AbstractFFTs.jl but only supports one-dimensional, contiguous, complex-valued arrays: Vector{ComplexF64} and Vector{ComplexF32}.","category":"page"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"Forward and inverse FFT:","category":"page"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"using RustFFT\n\ndata = ones(ComplexF64, 1)\nfft!(data)","category":"page"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"using RustFFT\n\ndata = ones(ComplexF64, 1)\nifft!(data)","category":"page"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"You can set several options by planning the FFT:","category":"page"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"using RustFFT\n\nplanner = new_planner(ComplexF64)\ndata = ones(ComplexF64, 1)\nplan = plan_fft!(data;\n    rustfft_checks=IgnoreArrayChecks(), # Don't track the array or check if its length is compatible\n    rustfft_gcsafe=GcSafe(), # Don't block the GC while an FFT is computed with this plan\n    rustfft_planner=planner) # Reuse an existing planner\nplan * data","category":"page"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"It's currently not possible to choose the specific algorithm that will be used to compute the transform.","category":"page"},{"location":"#RustFFT-specific-API","page":"RustFFT Documentation","title":"RustFFT-specific API","text":"","category":"section"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"Modules = [RustFFT]","category":"page"},{"location":"#RustFFT.AllArrayChecks","page":"RustFFT Documentation","title":"RustFFT.AllArrayChecks","text":"AllArrayChecks()\n\nTrack the array and check if the length is compatible with the plan. This is the default.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.ArrayChecks","page":"RustFFT Documentation","title":"RustFFT.ArrayChecks","text":"ArrayChecks\n\nSafety checks that can be disabled.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.Backward","page":"RustFFT Documentation","title":"RustFFT.Backward","text":"Backward()\n\nThe plan computes a backward FFT.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.Direction","page":"RustFFT Documentation","title":"RustFFT.Direction","text":"Direction\n\nThe direction of the plan.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.Forward","page":"RustFFT Documentation","title":"RustFFT.Forward","text":"Forward()\n\nThe plan computes a forward FFT.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.GcSafe","page":"RustFFT Documentation","title":"RustFFT.GcSafe","text":"GcSafe()\n\nA GC-safe plan doesn't block the GC.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.GcSafety","page":"RustFFT Documentation","title":"RustFFT.GcSafety","text":"GcSafety\n\nWhether or not a planned FFT is executed in a GC-safe state.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.GcUnsafe","page":"RustFFT Documentation","title":"RustFFT.GcUnsafe","text":"GcUnsafe()\n\nA GC-unsafe plan can block the GC. This is the default.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.IgnoreArrayChecks","page":"RustFFT Documentation","title":"RustFFT.IgnoreArrayChecks","text":"IgnoreArrayChecks()\n\nPerform no safety checks.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.IgnoreArrayTracking","page":"RustFFT Documentation","title":"RustFFT.IgnoreArrayTracking","text":"IgnoreArrayTracking()\n\nOnly check if the length is compatible with the plan.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.new_planner","page":"RustFFT Documentation","title":"RustFFT.new_planner","text":"new_planner(::Type{ComplexF32})\nnew_planner(::Type{ComplexF64})\n\nReturns a new planner. By default each plan creates a new planner but one can also be provided to the plan_*-functions as a keyword argument: rustfft_planner. By reusing the same planner, internal data is reused across different plans saving memory and setup time.\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"RustFFT Documentation","title":"Internals","text":"","category":"section"},{"location":"","page":"RustFFT Documentation","title":"RustFFT Documentation","text":"Modules = [RustFFT.Internal]","category":"page"},{"location":"#RustFFT.Internal.FftInstance","page":"RustFFT Documentation","title":"RustFFT.Internal.FftInstance","text":"FftInstance{T}\n\nAn instance of a plan to compute an FFT in some direction.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.Internal.FftPlanner","page":"RustFFT Documentation","title":"RustFFT.Internal.FftPlanner","text":"FftPlanner{T}\n\nA planner for forward and inverse FFTs of Vector{T}, T must be ComplexF32 or ComplexF64. A new planner can be created by calling the zero-argument constructor. The aliases FftPlanner32 and FftPlanner64 are also available.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.Internal.FftPlanner32","page":"RustFFT Documentation","title":"RustFFT.Internal.FftPlanner32","text":"FftPlanner32\n\nA planner for single-precision complex data.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.Internal.FftPlanner64","page":"RustFFT Documentation","title":"RustFFT.Internal.FftPlanner64","text":"FftPlanner64\n\nA planner for double-precision complex data.\n\n\n\n\n\n","category":"type"},{"location":"#RustFFT.Internal.rustfft_fft!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_fft!","text":"rustfft_fft!(instance::FftInstance{T}, buffer::Vector{T})\n\nComputes the planned FFT if buffer in-place. If the array is already tracked or the length is incompatible JlrsCore.JlrsError is thrown.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_fft_gcsafe!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_fft_gcsafe!","text":"rustfft_fft_gcsafe!(instance::FftInstance{T}, buffer::Vector{T})\n\nComputes the planned FFT if buffer in-place. If buffer is already tracked or its length is incompatible JlrsCore.JlrsError is thrown. The GC is allowed to collect while this function is called.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_fft_unchecked!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_fft_unchecked!","text":"rustfft_fft_unchecked!(instance::FftInstance{T}, buffer::Vector{T})\n\nComputes the planned FFT if buffer in-place.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_fft_unchecked_gcsafe!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_fft_unchecked_gcsafe!","text":"rustfft_fft_unchecked_gcsafe!(instance::FftInstance{T}, buffer::Vector{T})\n\nComputes the planned FFT if buffer in-place. The GC is allowed to collect while this function is called.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_fft_untracked!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_fft_untracked!","text":"rustfft_fft_untracked!(instance::FftInstance{T}, buffer::Vector{T})\n\nComputes the planned FFT if buffer in-place. If the length of buffer is incompatible JlrsCore.JlrsError is thrown.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_fft_untracked_gcsafe!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_fft_untracked_gcsafe!","text":"rustfft_fft_untracked_gcsafe!(instance::FftInstance{T}, buffer::Vector{T})\n\nComputes the planned FFT if buffer in-place. If the length of buffer is incompatible JlrsCore.JlrsError is thrown. The GC is allowed to collect while this function is called.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_plan_fft_forward!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_plan_fft_forward!","text":"rustfft_plan_fft_forward!(planner::FftPlanner{T}, len::UInt)\n\nPlan a forward FFT for Vector{T} data of length len. If the planner is already tracked JlrsCore.BorrowError is thrown.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_plan_fft_forward_untracked!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_plan_fft_forward_untracked!","text":"rustfft_plan_fft_forward_untracked!(planner::FftPlanner{T}, len::UInt)\n\nPlan a forward FFT for Vector{T} data of length len without tracking the planner.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_plan_fft_inverse!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_plan_fft_inverse!","text":"rustfft_plan_fft_inverse!(planner::FftPlanner{T}, len::UInt)\n\nPlan an inverse FFT for Vector{T} data of length len. If the planner is already tracked JlrsCore.BorrowError is thrown.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_plan_fft_inverse_untracked!","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_plan_fft_inverse_untracked!","text":"rustfft_plan_fft_inverse_untracked!(planner::FftPlanner{T}, len::UInt)\n\nPlan an inverse FFT for Vector{T} data of length len without tracking the planner.\n\n\n\n\n\n","category":"function"},{"location":"#RustFFT.Internal.rustfft_plan_size","page":"RustFFT Documentation","title":"RustFFT.Internal.rustfft_plan_size","text":"rustfft_plan_size(instance::FftInstance{T})\n\nThe length of the vector that can be transformed with plan.\n\n\n\n\n\n","category":"function"}]
}
